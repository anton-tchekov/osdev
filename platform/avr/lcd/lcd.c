/**
 * @file    lcd.c
 * @author  Anton Tchekov
 * @version 0.2
 * @date    17.05.2023
 */

#include <lcd.h>
#include <logger.h>
#include <avr/pgmspace.h>

void lcd_init(void)
{
	/* TODO: Initialize LCD */
	log_boot_P(PSTR("LCD driver initialized (not implemented)"));
}




#ifdef COMMENT

#define STATE_TX_WAIT      0
#define STATE_RX_WAIT      1
#define STATE_BUSY_WAIT    2

#define TYPE_EMPTY         0
#define TYPE_CMD           1
#define TYPE_PARAM0        2
#define TYPE_PARAM1        3
#define TYPE_DATA          4

#define MAX_COMMANDS       (1 << 7)
#define BUFFER_MASK        (MAX_COMMANDS - 1)

#define RCT_RECT           0
#define RCT_CHAR           1

#define FONT_WIDTH         5
#define FONT_HEIGHT        7

typedef struct
{
	u8 Type;
	i32 Char;
	u16 X, Y, W, H;
	u16 FG, BG;
} RenderCommand;

/* Ringpuffer */
static RenderCommand _commands[MAX_COMMANDS], *_window;
static u32 _step, _x, _y, _wp, _rp;

#define LCD(TYPE, u8) ((TYPE) | ((u32)((u8) & 0xFF) << 8))

static const u8 font5x7[] =
{
	0x00, 0x00, 0x00, 0x00, 0x00, /*   */
	0x00, 0x00, 0x5F, 0x00, 0x00, /* ! */
	0x00, 0x07, 0x00, 0x07, 0x00, /* " */
	0x14, 0x7F, 0x14, 0x7F, 0x14, /* # */
	0x24, 0x2A, 0x7F, 0x2A, 0x12, /* $ */
	0x23, 0x13, 0x08, 0x64, 0x62, /* % */
	0x36, 0x49, 0x55, 0x22, 0x50, /* & */
	0x00, 0x00, 0x03, 0x00, 0x00, /* ' */
	0x00, 0x1C, 0x22, 0x41, 0x00, /* ( */
	0x00, 0x41, 0x22, 0x1C, 0x00, /* ) */
	0x14, 0x08, 0x3E, 0x08, 0x14, /* * */
	0x08, 0x08, 0x3E, 0x08, 0x08, /* + */
	0x00, 0x50, 0x30, 0x00, 0x00, /* , */
	0x08, 0x08, 0x08, 0x08, 0x08, /* - */
	0x00, 0x60, 0x60, 0x00, 0x00, /* . */
	0x20, 0x10, 0x08, 0x04, 0x02, /* / */

	0x3E, 0x51, 0x49, 0x45, 0x3E, /* 0 */
	0x00, 0x42, 0x7F, 0x40, 0x00, /* 1 */
	0x62, 0x51, 0x49, 0x49, 0x46, /* 2 */
	0x22, 0x41, 0x49, 0x49, 0x36, /* 3 */
	0x18, 0x14, 0x12, 0x7F, 0x10, /* 4 */
	0x27, 0x45, 0x45, 0x45, 0x39, /* 5 */
	0x3C, 0x4A, 0x49, 0x49, 0x30, /* 6 */
	0x01, 0x71, 0x09, 0x05, 0x03, /* 7 */
	0x36, 0x49, 0x49, 0x49, 0x36, /* 8 */
	0x06, 0x49, 0x49, 0x29, 0x1E, /* 9 */

	0x00, 0x36, 0x36, 0x00, 0x00, /* : */
	0x00, 0x56, 0x36, 0x00, 0x00, /* ; */
	0x08, 0x14, 0x22, 0x41, 0x00, /* < */
	0x14, 0x14, 0x14, 0x14, 0x14, /* = */
	0x00, 0x41, 0x22, 0x14, 0x08, /* > */
	0x02, 0x01, 0x51, 0x09, 0x06, /* ? */
	0x32, 0x49, 0x79, 0x41, 0x3E, /* @ */

	0x7C, 0x12, 0x11, 0x12, 0x7C, /* A */
	0x41, 0x7F, 0x49, 0x49, 0x36, /* B */
	0x3E, 0x41, 0x41, 0x41, 0x22, /* C */
	0x41, 0x7F, 0x41, 0x41, 0x3E, /* D */
	0x7F, 0x49, 0x49, 0x49, 0x41, /* E */
	0x7F, 0x09, 0x09, 0x09, 0x01, /* F */
	0x3E, 0x41, 0x41, 0x49, 0x7A, /* G */
	0x7F, 0x08, 0x08, 0x08, 0x7F, /* H */
	0x00, 0x41, 0x7F, 0x41, 0x00, /* I */
	0x20, 0x40, 0x41, 0x3F, 0x01, /* J */
	0x7F, 0x08, 0x14, 0x22, 0x41, /* K */
	0x7F, 0x40, 0x40, 0x40, 0x40, /* L */
	0x7F, 0x02, 0x0C, 0x02, 0x7F, /* M */
	0x7F, 0x04, 0x08, 0x10, 0x7F, /* N */
	0x3E, 0x41, 0x41, 0x41, 0x3E, /* O */
	0x7F, 0x09, 0x09, 0x09, 0x06, /* P */
	0x3E, 0x41, 0x51, 0x21, 0x5E, /* Q */
	0x7F, 0x09, 0x19, 0x29, 0x46, /* R */
	0x26, 0x49, 0x49, 0x49, 0x32, /* S */
	0x01, 0x01, 0x7F, 0x01, 0x01, /* T */
	0x3F, 0x40, 0x40, 0x40, 0x3F, /* U */
	0x1F, 0x20, 0x40, 0x20, 0x1F, /* V */
	0x3F, 0x40, 0x38, 0x40, 0x3F, /* W */
	0x63, 0x14, 0x08, 0x14, 0x63, /* X */
	0x07, 0x08, 0x70, 0x08, 0x07, /* Y */
	0x61, 0x51, 0x49, 0x45, 0x43, /* Z */

	0x00, 0x7F, 0x41, 0x41, 0x00, /* [ */
	0x02, 0x04, 0x08, 0x10, 0x20, /* \ */
	0x00, 0x41, 0x41, 0x7F, 0x00, /* ] */
	0x04, 0x02, 0x01, 0x02, 0x04, /* ^ */
	0x40, 0x40, 0x40, 0x40, 0x40, /* _ */
	0x00, 0x01, 0x02, 0x04, 0x00, /* ` */

	0x20, 0x54, 0x54, 0x54, 0x78, /* a */
	0x7F, 0x48, 0x44, 0x44, 0x38, /* b */
	0x38, 0x44, 0x44, 0x44, 0x20, /* c */
	0x38, 0x44, 0x44, 0x48, 0x7F, /* d */
	0x38, 0x54, 0x54, 0x54, 0x18, /* e */
	0x08, 0x7E, 0x09, 0x01, 0x02, /* f */
	0x08, 0x54, 0x54, 0x54, 0x3C, /* g */
	0x7F, 0x08, 0x04, 0x04, 0x78, /* h */
	0x00, 0x48, 0x7D, 0x40, 0x00, /* i */
	0x20, 0x40, 0x44, 0x3D, 0x00, /* j */
	0x7F, 0x10, 0x28, 0x44, 0x00, /* k */
	0x00, 0x41, 0x7F, 0x40, 0x00, /* l */
	0x7C, 0x04, 0x78, 0x04, 0x78, /* m */
	0x7C, 0x08, 0x04, 0x04, 0x78, /* n */
	0x38, 0x44, 0x44, 0x44, 0x38, /* o */
	0x7C, 0x14, 0x14, 0x14, 0x08, /* p */
	0x08, 0x14, 0x14, 0x18, 0x7C, /* q */
	0x7C, 0x08, 0x04, 0x04, 0x08, /* r */
	0x48, 0x54, 0x54, 0x54, 0x20, /* s */
	0x04, 0x3F, 0x44, 0x40, 0x20, /* t */
	0x3C, 0x40, 0x40, 0x20, 0x7C, /* u */
	0x1C, 0x20, 0x40, 0x20, 0x1C, /* v */
	0x3C, 0x40, 0x30, 0x40, 0x3C, /* w */
	0x44, 0x28, 0x10, 0x28, 0x44, /* x */
	0x0C, 0x50, 0x50, 0x50, 0x3C, /* y */
	0x44, 0x64, 0x54, 0x4C, 0x44, /* z */

	0x00, 0x08, 0x36, 0x41, 0x00, /* { */
	0x00, 0x00, 0x7F, 0x00, 0x00, /* | */
	0x00, 0x41, 0x36, 0x08, 0x00, /* } */
	0x10, 0x08, 0x08, 0x10, 0x08  /* ~ */
};

static u32 _next_step(void)
{
	u16 value, x, y, w, h, ex, ey;
	u32 ret = TYPE_EMPTY;
	if(!_window)
	{
		return ret;
	}

	x  = _window->X;
	y  = _window->Y;
	w  = _window->W;
	h  = _window->H;
	ex = x + w - 1;
	ey = y + h - 1;

	switch(_step)
	{
		case  0: ret = LCD(TYPE_CMD, 0x2A);       break;
		case  1: ret = LCD(TYPE_PARAM0, 0);       break;
		case  2: ret = LCD(TYPE_PARAM1, x >> 8);  break;
		case  3: ret = LCD(TYPE_PARAM0, 0);       break;
		case  4: ret = LCD(TYPE_PARAM1, x);       break;
		case  5: ret = LCD(TYPE_PARAM0, 0);       break;
		case  6: ret = LCD(TYPE_PARAM1, ex >> 8); break;
		case  7: ret = LCD(TYPE_PARAM0, 0);       break;
		case  8: ret = LCD(TYPE_PARAM1, ex);      break;

		case  9: ret = LCD(TYPE_CMD, 0x2B);       break;
		case 10: ret = LCD(TYPE_PARAM0, 0);       break;
		case 11: ret = LCD(TYPE_PARAM1, y >> 8);  break;
		case 12: ret = LCD(TYPE_PARAM0, 0);       break;
		case 13: ret = LCD(TYPE_PARAM1, y);       break;
		case 14: ret = LCD(TYPE_PARAM0, 0);       break;
		case 15: ret = LCD(TYPE_PARAM1, ey >> 8); break;
		case 16: ret = LCD(TYPE_PARAM0, 0);       break;
		case 17: ret = LCD(TYPE_PARAM1, ey);      break;

		case 18: ret = LCD(TYPE_CMD, 0x2C);       break;

		default:
			if(_window->Type == RCT_RECT)
			{
				value = _window->FG;
			}
			else if(_window->Type == RCT_CHAR)
			{
				value = ((font5x7[(_window->Char - 32) * 5 + _x] >> _y) & 1)
					? _window->FG : _window->BG;
			}

			if(_step & 1)
			{
				value >>= 8;
			}

			if(_step == 19)
			{
				ret = LCD(TYPE_PARAM0, value);
			}
			else
			{
				ret = LCD(TYPE_DATA, value);
			}

			if(!(_step & 1))
			{
				if(++_x == w)
				{
					_x = 0;
					if(++_y == h)
					{
						ret = LCD(TYPE_PARAM1, value);
						_window = NULL;
					}
				}
			}
			break;
	}

	++_step;
	return ret;
}

u16 asynclcd_color(u8 r, u8 g, u8 b)
{
	return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
}

void asynclcd_rect(i32 x, i32 y, i32 w, i32 h, u16 color)
{
	if(_wp >= _rp + MAX_COMMANDS)
	{
		return;
	}

	RenderCommand *rc = &_commands[_wp++ & BUFFER_MASK];
	rc->Type = RCT_RECT;
	rc->X = x;
	rc->Y = y;
	rc->W = w;
	rc->H = h;
	rc->FG = color;
}

i32 asynclcd_char(i32 x, i32 y, u16 fg, u16 bg, i32 c)
{
	if(_wp >= _rp + MAX_COMMANDS)
	{
		return 0;
	}

	RenderCommand *rc = &_commands[_wp++ & BUFFER_MASK];
	rc->Type = RCT_CHAR;
	rc->Char = c;
	rc->X = x;
	rc->Y = y;
	rc->W = FONT_WIDTH;
	rc->H = FONT_HEIGHT;
	rc->FG = fg;
	rc->BG = bg;
	return FONT_WIDTH + 1;
}

void asynclcd_string(i32 x, i32 y, u16 fg, u16 bg, const char *s)
{
	i32 c;
	while((c = *s++))
	{
		x += asynclcd_char(x, y, fg, bg, c);
	}
}

void asynclcd_update(void)
{
	static u8 _type, _state;

	switch(_state)
	{
		case STATE_TX_WAIT:
			if(SR & SPI_SR_TXE)
			{
				u32 ret = _next_step();
				if(ret)
				{
					u8 byte = ret >> 8;
					_type = ret;

					if(_type == TYPE_CMD)
					{
						LCD_DC_0;
						LCD_CS_0;
					}
					else if(_type == TYPE_PARAM0)
					{
						LCD_DC_1;
						LCD_CS_0;
					}

					DR = byte;
					_state = STATE_RX_WAIT;
				}
				else
				{
					/* next render window */
					if(_rp < _wp)
					{
						_x = 0;
						_y = 0;
						_step = 0;
						_window = &_commands[_rp++ & BUFFER_MASK];
					}
				}
			}
			break;

		case STATE_RX_WAIT:
			if(SR & SPI_SR_RXNE)
			{
				_state = STATE_BUSY_WAIT;
			}
			break;

		case STATE_BUSY_WAIT:
			if(!(SR & SPI_SR_BSY))
			{
				volatile u8 data = DR;
				if(_type == TYPE_CMD ||
					_type == TYPE_PARAM1)
				{
					LCD_CS_1;
				}

				_state = STATE_TX_WAIT;
			}
			break;
	}
}

bool asynclcd_ready(void)
{
	return _rp == _wp;
}

#endif


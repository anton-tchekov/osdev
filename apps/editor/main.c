/**
 * @file    main.c
 * @author  Anton Tchekov
 * @version 0.1
 * @date    24.05.2023
 * @brief   Text/Code Editor App
 */

#include <std.h>
#include <ubuntu_regular.h>
#include "keyword.h"

/** Initial code vector capacity */
#define INITIAL_CODE_CAPACITY    16

/** Editor line height in pixels */
#define LINE_HEIGHT              12

/** TODO: File for testing syntax highligher, remove when file loading done */
static const char _file[] =
{
	0x76, 0x6F, 0x69, 0x64, 0x20, 0x65, 0x64, 0x69, 0x74, 0x6F, 0x72, 0x5F, 0x62, 0x61, 0x63, 0x6B,
	0x73, 0x70, 0x61, 0x63, 0x65, 0x28, 0x45, 0x64, 0x69, 0x74, 0x6F, 0x72, 0x20, 0x2A, 0x65, 0x64,
	0x29, 0x0A, 0x7B, 0x0A, 0x09, 0x56, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x20, 0x2A, 0x6C, 0x69, 0x6E,
	0x65, 0x20, 0x3D, 0x20, 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x5F, 0x67, 0x65, 0x74, 0x28, 0x26,
	0x65, 0x64, 0x2D, 0x3E, 0x4C, 0x69, 0x6E, 0x65, 0x73, 0x2C, 0x20, 0x65, 0x64, 0x2D, 0x3E, 0x43,
	0x75, 0x72, 0x73, 0x6F, 0x72, 0x59, 0x29, 0x3B, 0x0A, 0x09, 0x69, 0x66, 0x20, 0x28, 0x65, 0x64,
	0x2D, 0x3E, 0x43, 0x75, 0x72, 0x73, 0x6F, 0x72, 0x58, 0x20, 0x3D, 0x3D, 0x20, 0x30, 0x29, 0x0A,
	0x09, 0x7B, 0x0A, 0x09, 0x09, 0x69, 0x66, 0x20, 0x28, 0x65, 0x64, 0x2D, 0x3E, 0x43, 0x75, 0x72,
	0x73, 0x6F, 0x72, 0x59, 0x20, 0x3E, 0x20, 0x30, 0x29, 0x0A, 0x09, 0x09, 0x7B, 0x0A, 0x09, 0x09,
	0x09, 0x2F, 0x2A, 0x20, 0x6D, 0x65, 0x72, 0x67, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x70,
	0x72, 0x65, 0x76, 0x69, 0x6F, 0x75, 0x73, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x2A, 0x2F, 0x0A,
	0x09, 0x09, 0x09, 0x56, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x20, 0x2A, 0x70, 0x72, 0x65, 0x76, 0x20,
	0x3D, 0x20, 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x5F, 0x67, 0x65, 0x74, 0x28, 0x26, 0x65, 0x64,
	0x2D, 0x3E, 0x4C, 0x69, 0x6E, 0x65, 0x73, 0x2C, 0x20, 0x2D, 0x2D, 0x65, 0x64, 0x2D, 0x3E, 0x43,
	0x75, 0x72, 0x73, 0x6F, 0x72, 0x59, 0x29, 0x3B, 0x0A, 0x09, 0x09, 0x09, 0x65, 0x64, 0x2D, 0x3E,
	0x43, 0x75, 0x72, 0x73, 0x6F, 0x72, 0x58, 0x20, 0x3D, 0x20, 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72,
	0x5F, 0x6C, 0x65, 0x6E, 0x28, 0x70, 0x72, 0x65, 0x76, 0x29, 0x3B, 0x0A, 0x09, 0x09, 0x09, 0x76,
	0x65, 0x63, 0x74, 0x6F, 0x72, 0x5F, 0x70, 0x75, 0x73, 0x68, 0x5F, 0x72, 0x61, 0x6E, 0x67, 0x65,
	0x28, 0x70, 0x72, 0x65, 0x76, 0x2C, 0x20, 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x5F, 0x6C, 0x65,
	0x6E, 0x28, 0x6C, 0x69, 0x6E, 0x65, 0x29, 0x2C, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x2D, 0x3E, 0x44,
	0x61, 0x74, 0x61, 0x29, 0x3B, 0x0A, 0x09, 0x09, 0x09, 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x5F,
	0x64, 0x65, 0x73, 0x74, 0x72, 0x6F, 0x79, 0x28, 0x6C, 0x69, 0x6E, 0x65, 0x29, 0x3B, 0x0A, 0x09,
	0x09, 0x09, 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x5F, 0x72, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x28,
	0x26, 0x65, 0x64, 0x2D, 0x3E, 0x4C, 0x69, 0x6E, 0x65, 0x73, 0x2C, 0x20, 0x65, 0x64, 0x2D, 0x3E,
	0x43, 0x75, 0x72, 0x73, 0x6F, 0x72, 0x59, 0x20, 0x2B, 0x20, 0x31, 0x29, 0x3B, 0x0A, 0x09, 0x09,
	0x7D, 0x0A, 0x09, 0x7D, 0x0A, 0x09, 0x65, 0x6C, 0x73, 0x65, 0x0A, 0x09, 0x7B, 0x0A, 0x09, 0x09,
	0x2F, 0x2A, 0x20, 0x64, 0x65, 0x6C, 0x65, 0x74, 0x65, 0x20, 0x70, 0x72, 0x65, 0x76, 0x20, 0x63,
	0x68, 0x61, 0x72, 0x20, 0x2A, 0x2F, 0x0A, 0x09, 0x09, 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x5F,
	0x72, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x28, 0x6C, 0x69, 0x6E, 0x65, 0x2C, 0x20, 0x2D, 0x2D, 0x65,
	0x64, 0x2D, 0x3E, 0x43, 0x75, 0x72, 0x73, 0x6F, 0x72, 0x58, 0x29, 0x3B, 0x0A, 0x09, 0x7D, 0x0A,
	0x7D
};

/** Vector containing source code */
static Vector _code;

/** Editor source code window */
static Window _window_editor;

/**
 * @brief Main key event handler
 *
 * @param key The key that was pressed
 * @param chr The character corresponding to the key
 * @param state Key state (pressed, repeat, released)
 */
void event_key(Key key, i32 chr, KeyState state)
{
	(void)key, (void)chr, (void)state;
}

/**
 * @brief Draw editor line numbers
 *
 * @param max_line Number of line numbers to draw
 */
static void _draw_line_numbers(i32 max_line)
{
	static i32 lines_count = 0;

	if(lines_count == max_line)
	{
		return;
	}

	if(lines_count > max_line)
	{
		i32 start;

		/* Remove line numbers by drawing rectangle on top */
		start = max_line * LINE_HEIGHT + TITLE_BAR_HEIGHT;
		gfx_rect(0, start, GFX_HEIGHT - start, 29, THEME_BLACK);
	}
	else
	{
		char buf[16];
		i32 i;

		/* Add line numbers */
		for(i = lines_count; i <= max_line; ++i)
		{
			snprintf(buf, sizeof(buf), "%d", i + 1);
			font_string(
				25 - font_string_width(buf, ubuntu_regular),
				i * LINE_HEIGHT + 22,
				buf, ubuntu_regular, COLOR_WHITE, THEME_BLACK);
		}
	}

	lines_count = max_line;
}

/**
 * @brief Get the color of a bracket at a nesting level
 *
 * @param nesting At how many nesting levels the bracket is located
 * @return Color the bracket should receive
 */
static Color _get_bracket_color(i32 nesting)
{
	static Color _colors[] =
	{
		0xFFD700FF,
		0xDA70D6FF,
		0x179FFFFF
	};

	return _colors[nesting % ARRLEN(_colors)];
}

/**
 * @brief Render code to screen with syntax highlighting
 */
static void _draw_code(void)
{
	i32 i, j, brackets, len, line, col, keyword_remain;
	bool in_comment, in_string, in_char;
	char *text, c;
	Color color;

	len = vector_len(&_code);
	text = vector_data(&_code);

	in_comment = false;
	in_string = false;
	in_char = false;
	keyword_remain = 0;

	col = 0;
	line = 0;
	brackets = 0;

	for(i = 0; i < len; ++i)
	{
		color = COLOR_WHITE;
		c = text[i];

		if(!keyword_remain && !isalnum(text[i - 1]))
		{
			i32 word_len;

			/* Find end of word */
			for (j = i; j < len; ++j)
			{
				if (!isalnum(text[j]))
				{
					break;
				}
			}

			word_len = j - i;
			if(keyword_detect(&text[i], word_len))
			{
				keyword_remain = word_len;
				color = COLOR_BLUE;
			}
		}

		if(c == '(' || c == '[' || c == '{')
		{
			color = _get_bracket_color(brackets);
			++brackets;
		}
		else if(c == ')' || c == ']' || c == '}')
		{
			--brackets;
			color = _get_bracket_color(brackets);
		}
		else if(isdigit(c))
		{
			color = COLOR_LIME;
		}

		if(keyword_remain)
		{
			--keyword_remain;
			color = COLOR_BLUE;
		}

		if(c == '\'' && text[i - 1] != '\\' && !in_string)
		{
			color = COLOR_ORANGE;
			in_char = !in_char;
		}

		if(c == '"' && text[i - 1] != '\\' && !in_char)
		{
			color = COLOR_ORANGE;
			in_string = !in_string;
		}

		if(c == '/' && text[i + 1] == '*')
		{
			color = COLOR_GREEN;
			in_comment = true;
		}

		if(c == '/' && text[i - 1] == '*')
		{
			color = COLOR_GREEN;
			in_comment = false;
		}

		if(in_char || in_string)
		{
			color = COLOR_ORANGE;
		}

		if(in_comment)
		{
			color = COLOR_GREEN;
		}

		if(c == '\n')
		{
			col = 0;
			++line;
		}
		else
		{
			i32 x, y;

			x = col * 8 + 33;
			y = line * LINE_HEIGHT + 22;
			++col;
			if (x <= GFX_WIDTH - 10 && y <= GFX_HEIGHT - 10)
			{
				font_string_len(x, y, &c, 1, ubuntu_regular, color, COLOR_BLACK);
			}
		}
	}
}

void setup(void)
{
	keyboard_register_event(event_key);
	keyword_init();

	vector_init(&_code, sizeof(char), INITIAL_CODE_CAPACITY);
	vector_set(&_code, _file, ARRLEN(_file));

	window_init(&_window_editor, "Editor", NULL, 0, NULL);
	window_open(&_window_editor);

	gfx_rect(30, 20, 1, GFX_HEIGHT - 20, THEME_LIGHT);
	_draw_line_numbers(37);
	_draw_code();
}

void loop(void)
{
}
